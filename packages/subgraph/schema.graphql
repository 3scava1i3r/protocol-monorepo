#################
# Event Entities #
#################
interface Event {
    id: ID!
    transaction: Transaction!
}

type Transaction @entity {
    id: ID!
    timestamp: BigInt!
    blockNumber: BigInt!
    events: [Event!]! @derivedFrom(field: "transaction")
}

enum FlowActionType {
	create,
	update,
	terminate
}

#     ConstantFlowAgreementV1    #
type FlowUpdated implements Event @entity {
	id: ID! 
	transaction: Transaction!
	token: Token!
	sender: Bytes!
	receiver: Bytes!
	flowRate: BigInt!
	totalSenderFlowRate: BigInt!
	totalReceiverFlowRate: BigInt!
	userData: Bytes!
	# Custom Properties (not on event)
	oldFlowRate: BigInt!
	type: FlowActionType
}

#  InstantDistributionAgreementV1 #
type IndexCreated implements Event @entity {
	id: ID! 
	transaction: Transaction!
	token: Token!
	publisher: Bytes!
	indexId: BigInt!
	userData: Bytes!
}

type IndexUpdated implements Event @entity {
	id: ID!
	transaction: Transaction!
	token: Token!
	publisher: Bytes!
	indexId: BigInt!
	oldIndexValue: BigInt!
	newIndexValue: BigInt!
	totalUnitsPending: BigInt!
	totalUnitsApproved: BigInt!
	userData: Bytes!
}

type SubscriptionApproved implements Event @entity {
	id: ID!
	transaction: Transaction!
	token: Token!
	subscriber: Bytes!
	publisher: Bytes!
	indexId: BigInt!
	userData: Bytes!
}

type SubscriptionRevoked implements Event @entity {
	id: ID!
	transaction: Transaction!
	token: Token!
	subscriber: Bytes!
	publisher: Bytes!
	indexId: BigInt!
	userData: Bytes!
}

type SubscriptionUnitsUpdated implements Event @entity {
	id: ID!
	transaction: Transaction!
	token: Token!
	subscriber: Bytes!
	publisher: Bytes!
	indexId: BigInt!
	units: BigInt!
	userData: Bytes!
}

#     Superfluid    #
type GovernanceReplaced implements Event @entity {
	id: ID!
	transaction: Transaction!
	oldGovernance: Bytes!
	newGovernance: Bytes!
}

type AgreementClassRegistered implements Event @entity {
	id: ID!
	transaction: Transaction!
	agreementType: Bytes!
	code: Bytes!
}

type AgreementClassUpdated implements Event @entity {
	id: ID!
	transaction: Transaction!
	agreementType: Bytes!
	code: Bytes!
}

type SuperTokenFactoryUpdated implements Event @entity {
	id: ID!
	transaction: Transaction!
	newFactory: Bytes!
}

type SuperTokenLogicUpdated implements Event @entity {
	id: ID!
	transaction: Transaction!
	token: Bytes!
	code: Bytes!
}

type AppRegistered implements Event @entity {
	id: ID!
	transaction: Transaction!
	app: Bytes!
}

type Jail implements Event @entity {
	id: ID!
	transaction: Transaction!
	app: Bytes!
	reason: BigInt!
}


# #     SuperfluidGovernance    #
type ConfigChanged implements Event @entity {
	id: ID!
	transaction: Transaction!
	host: Bytes!
	superToken: Bytes!
	key: Bytes!
	set: Boolean!
	value: BigInt!
}

type RewardAddressChanged implements Event @entity {
	id: ID!
	transaction: Transaction!
	host: Bytes!
	superToken: Bytes!
	set: Boolean!
	rewardAddress: Bytes!
}

type CFAv1LiquidationPeriodChanged implements Event @entity {
	id: ID!
	transaction: Transaction!
	host: Bytes!
	superToken: Bytes!
	set: Boolean!
	liquidationPeriod: BigInt!
}

type TrustedForwarderChanged implements Event @entity {
	id: ID!
	transaction: Transaction!
	host: Bytes!
	superToken: Bytes!
	set: Boolean!
	forwarder: Bytes!
	enabled: Boolean!
}


#     SuperToken    #
type AgreementLiquidatedBy implements Event @entity {
	id: ID!
	transaction: Transaction!
	token: Token!
	liquidatorAccount: Bytes!
	agreementClass: Bytes!
	agreementId: Bytes!
	penaltyAccount: Bytes!
	bondAccount: Bytes!
	rewardAmount: BigInt!
	bailoutAmount: BigInt!
}

type TokenUpgraded implements Event @entity {
    id: ID!
    account: Bytes!
    transaction: Transaction!
    token: Token!
    amount: BigInt!
}

type TokenDowngraded implements Event @entity {
    id: ID!
    account: Bytes!
    transaction: Transaction!
    token: Token!
    amount: BigInt!
}

type Transfer implements Event @entity {
    id: ID!
    transaction: Transaction!
    from: Bytes!
    to: Bytes!
    value: BigInt!
    token: Token!
}

#     SuperTokenFactory    #
type SuperTokenCreated implements Event @entity {
    id: ID!
    transaction: Transaction!
	token: Token!
}

type SuperTokenLogicCreated implements Event @entity {
    id: ID!
    transaction: Transaction!
	token: Token!
}

type CustomSuperTokenCreated implements Event @entity {
    id: ID!
    transaction: Transaction!
	token: Token!
}


####################
#   HOL Entities   #
####################
interface BaseEntity {
    id: ID!
	createdAt: BigInt!
    updatedAt: BigInt!
}
# Note: Make sure to implement BaseEntity
type Account implements BaseEntity @entity {
    id: ID!
	createdAt: BigInt!
    updatedAt: BigInt!
}

type Token implements BaseEntity @entity {
    # Note: All Tokens are Super Tokens for this subgraph
    id: ID!
	createdAt: BigInt!
    updatedAt: BigInt!
    name: String!
    symbol: String!
    underlyingAddress: Bytes! # Underlying ERC20
}

type Stream implements BaseEntity @entity {
	id: ID!
	createdAt: BigInt!
    updatedAt: BigInt!
	token: Token!
	sender: Account!
	receiver: Account!
	currentFlowRate: BigInt!
	streamedUntilLastUpdate: BigInt!
}

type Subscriber implements BaseEntity @entity {
    id: ID!
	createdAt: BigInt!
    updatedAt: BigInt!
    token: Token!
    subscriber: Account!
    publisher: Account!
    indexId: BigInt!
    userData: Bytes!
    # ---------------------------------- state ----------------------------------
    approved: Boolean!
    units: BigInt!
    totalReceivedUntilLastUpdate: BigInt!
    totalPendingApproval: BigInt!
	lastIndexValue: BigInt! # used to calculate the "totalFundsSent"
    # ---------------------------------- links ----------------------------------
    index: Index!
}

type Index implements BaseEntity @entity {
    id: ID!
	createdAt: BigInt!
    updatedAt: BigInt!
    token: Token!
    publisher: Account!
    indexId: BigInt!
    # ---------------------------------- state ----------------------------------
    userData: Bytes!
    oldIndexValue: BigInt!
    newIndexValue: BigInt!
    totalUnitsPending: BigInt!
    totalUnitsApproved: BigInt!
    totalUnits: BigInt!
    totalUnitsDistributed: BigInt!
}


####################
#  Aggr. Entities  #
####################
## TODO: Reevaluate the schema design if you have accounted for all cases where you 
## need to update the aggregate entities
type AccountTokenSnapshot @entity {
	id: ID!
	account: Account!
	token: Token!
	balance: BigInt! # must be updated each time subscription units is updated
	totalNetFlowRate: BigInt!
	totalAmountPending: BigInt!
	totalAmountApproved: BigInt!
	totalSubscriptions: BigInt!
	totalApprovedSubscriptions: BigInt!
}

type TokenStats @entity {
	id: ID!
	token: Token!
	totalNumberOfStreams: BigInt!
	totalFlowRate: BigInt!
	totalNumberOfIndexes: BigInt!
	totalAmountPending: BigInt!
	totalAmountApproved: BigInt!
	totalAmountDistributed: BigInt!
	totalSubscribers: BigInt!
	totalApprovedSubscribers: BigInt!
}